{
  "hash": "04589edcbd3c98be0b845803ce3221f2",
  "result": {
    "markdown": "---\ntitle: Currr\ndate: '2023-02-14'\nslug: currr\ncategories:\n  - Package\nimage: featured.png\n---\n\n\nI've recently developed a new R package called \\`currr\\` (checkpoints & purrr). It manages time-consuming iterations, parallel computing and multitasking.\n\n------------------------------------------------------------------------\n\n# currr <img src=\"https://raw.githubusercontent.com/MarcellGranat/marcellgranat-website/main/static/currr/logo.png\" align=\"right\" width=\"120px\"/>\n\n<!-- badges: start -->\n\n![](https://www.r-pkg.org/badges/version/currr){fig-align=\"left\"}\n\n<!-- badges: end -->\n\n## Overview\n\n> A long journey is best broken into small steps, and the importance of taking a rest must never be underestimated.\n\nThe **currr** package is a wrapper for the `purrr::map()` family but extends the iteration process with a certain number of **checkpoints** (`currr` = `c`heckpoints + `purrr`), where the evaluated results are saved, and we can always restart from there.\n\n![](https://raw.githubusercontent.com/MarcellGranat/marcellgranat-website/main/static/currr/example.gif){align=\"center\" fig-align=\"center\" width=\"100%\"}\n\nImplementations of the family of map() functions with a frequent saving of the intermediate results. The contained functions let you **start** the evaluation of the iterations **where you stopped** (reading the already evaluated ones from the cache), and **work with the currently evaluated iterations** while the remaining ones are running in a background job. **Parallel** computing is also easier with the `workers` parameter.\n\n## Installation\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"currr\")\n```\n:::\n\n\n## Usage\n\nThe following example uses `currr` to present an everyday issue: run a time-demanding iteration, but you want to rerun it again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(currr)\n\noptions(currr.folder = \".currr\", currr.wait = Inf)\n# folder in your wd, where to save cache data\n\navg_n <- function(.data, .col, x) {\n  # meaningless function that takes about 1 sec\n  Sys.sleep(1)\n\n  .data |>\n    dplyr::pull({{ .col }}) |>\n    (\\(m) mean(m) * x) ()\n}\n```\n:::\n\n\n### Checkpoints\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntictoc::tic(msg = \"First evaluation\")\n\ncp_map(.x = 1:50, .f = avg_n, .data = iris,\n       .col = Sepal.Length,\n       name = \"iris_mean\", cp_options = ) |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n|██████████████████████████████████████████████████ | 2% ETA:  50 sec                         \n|██████████████████████████████████████████████████ | 4% ETA:  49 sec                         \n|██████████████████████████████████████████████████ | 6% ETA:  48 sec                         \n|██████████████████████████████████████████████████ | 8% ETA:  47 sec                         \n|██████████████████████████████████████████████████ | 10% ETA:  46 sec                         \n|██████████████████████████████████████████████████ | 12% ETA:  45 sec                         \n|██████████████████████████████████████████████████ | 14% ETA:  44 sec                         \n|██████████████████████████████████████████████████ | 16% ETA:  43 sec                         \n|██████████████████████████████████████████████████ | 18% ETA:  42 sec                         \n|██████████████████████████████████████████████████ | 20% ETA:  41 sec                         \n|██████████████████████████████████████████████████ | 22% ETA:  40 sec                         \n|██████████████████████████████████████████████████ | 24% ETA:  39 sec                         \n|██████████████████████████████████████████████████ | 26% ETA:  38 sec                         \n|██████████████████████████████████████████████████ | 28% ETA:  37 sec                         \n|██████████████████████████████████████████████████ | 30% ETA:  36 sec                         \n|██████████████████████████████████████████████████ | 32% ETA:  35 sec                         \n|██████████████████████████████████████████████████ | 34% ETA:  34 sec                         \n|██████████████████████████████████████████████████ | 36% ETA:  33 sec                         \n|██████████████████████████████████████████████████ | 38% ETA:  32 sec                         \n|██████████████████████████████████████████████████ | 40% ETA:  31 sec                         \n|██████████████████████████████████████████████████ | 42% ETA:  30 sec                         \n|██████████████████████████████████████████████████ | 44% ETA:  29 sec                         \n|██████████████████████████████████████████████████ | 46% ETA:  28 sec                         \n|██████████████████████████████████████████████████ | 48% ETA:  27 sec                         \n|██████████████████████████████████████████████████ | 50% ETA:  26 sec                         \n|██████████████████████████████████████████████████ | 52% ETA:  25 sec                         \n|██████████████████████████████████████████████████ | 54% ETA:  24 sec                         \n|██████████████████████████████████████████████████ | 56% ETA:  23 sec                         \n|██████████████████████████████████████████████████ | 58% ETA:  22 sec                         \n|██████████████████████████████████████████████████ | 60% ETA:  21 sec                         \n|██████████████████████████████████████████████████ | 62% ETA:  20 sec                         \n|██████████████████████████████████████████████████ | 64% ETA:  19 sec                         \n|██████████████████████████████████████████████████ | 66% ETA:  18 sec                         \n|██████████████████████████████████████████████████ | 68% ETA:  17 sec                         \n|██████████████████████████████████████████████████ | 70% ETA:  16 sec                         \n|██████████████████████████████████████████████████ | 72% ETA:  15 sec                         \n|██████████████████████████████████████████████████ | 74% ETA:  14 sec                         \n|██████████████████████████████████████████████████ | 76% ETA:  13 sec                         \n|██████████████████████████████████████████████████ | 78% ETA:  12 sec                         \n|██████████████████████████████████████████████████ | 80% ETA:  11 sec                         \n|██████████████████████████████████████████████████ | 82% ETA:  10 sec                         \n|██████████████████████████████████████████████████ | 84% ETA:  9 sec                          \n|██████████████████████████████████████████████████ | 86% ETA:  8 sec                          \n|██████████████████████████████████████████████████ | 88% ETA:  7 sec                          \n|██████████████████████████████████████████████████ | 90% ETA:  6 sec                          \n|██████████████████████████████████████████████████ | 92% ETA:  5 sec                          \n|██████████████████████████████████████████████████ | 94% ETA:  4 sec                          \n|██████████████████████████████████████████████████ | 96% ETA:  3 sec                          \n|██████████████████████████████████████████████████ | 98% ETA:  2 sec                          \n|██████████████████████████████████████████████████ | 100% ETA:  0 sec                          \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 5.843333\n\n[[2]]\n[1] 11.68667\n\n[[3]]\n[1] 17.53\n```\n:::\n\n```{.r .cell-code}\ntictoc::toc() # ~ 1:50 => 50 x 1 sec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFirst evaluation: 52.782 sec elapsed\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntictoc::tic(msg = \"Second evaluation\")\n\ncp_map(.x = 1:50, .f = avg_n, .data = iris,\n       .col = Sepal.Length,\n       name = \"iris_mean\") |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n✓ Everything is unchanged. Reading cache.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 5.843333\n\n[[2]]\n[1] 11.68667\n\n[[3]]\n[1] 17.53\n```\n:::\n\n```{.r .cell-code}\ntictoc::toc() # ~ 0 sec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSecond evaluation: 0.034 sec elapsed\n```\n:::\n:::\n\n\nIf the `.x` input and `.f` are the same, then the 2nd time you call the function, it reads the outcome from the specified folder (`.currr`). Also if `.x` changes, but some of its part remain the same, then that part is taken from the previously saved results, and only the new elements of `.x` are called for evaluation. (If `.f` changes, then the process will start from zero.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntictoc::tic(msg = \"Partly modification\")\n\ncp_map(.x = 20:60, .f = avg_n, .data = iris,\n       .col = Sepal.Length,\n       name = \"iris_mean\") |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n⚠ .x has changed. Looking for mathcing result to save them as cache\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n◌ Cache updated based on the new .x values\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n|███████████████████████████████████████████████████████████████████████████████████████ | 2% ETA:  41 sec                         \n|█████████████████████████████████████████████████████████████████████████████████████ | 6% ETA:  40 sec                         \n|████████████████████████████████████████████████████████████████████████████████████ | 8% ETA:  39 sec                         \n|███████████████████████████████████████████████████████████████████████████████████ | 10% ETA:  38 sec                         \n|██████████████████████████████████████████████████████████████████████████████████ | 12% ETA:  37 sec                         \n|████████████████████████████████████████████████████████████████████████████████ | 16% ETA:  36 sec                         \n|███████████████████████████████████████████████████████████████████████████████ | 18% ETA:  35 sec                         \n|██████████████████████████████████████████████████████████████████████████████ | 20% ETA:  34 sec                         \n|█████████████████████████████████████████████████████████████████████████████ | 22% ETA:  33 sec                         \n|████████████████████████████████████████████████████████████████████████████ | 24% ETA:  32 sec                         \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 116.8667\n\n[[2]]\n[1] 122.71\n\n[[3]]\n[1] 128.5533\n```\n:::\n\n```{.r .cell-code}\ntictoc::toc() # ~ 50:60 => 10 x 1 sec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPartly modification: 10.384 sec elapsed\n```\n:::\n:::\n\n\nYou can remove the cache files, if you want to reset the process (or remove the already unnecessary files from your folder).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# only cache files for iris_mean\nremove_currr_cache(\"iris_mean\")\n\n# all cache files\nremove_currr_cache()\n```\n:::\n\n\n### Background process\n\nThis is another functionality that makes `currr` to be cool. Working in RStudio you can set the `wait` parameter to 0-1/1+, define how many iterations you want to wait, and then let R work on the remaining iterations in the background, while you can work with the evaluated ones. If wait \\< 1, then it is interpreted as what proportion of the iterations you want to wait. Whenever you recall the function, it will return the already evaluated ones (use the `fill` parameter to specify whether you want to get `NULL`s to the pending ones.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(currr.wait = 20, currr.fill = FALSE)\n```\n:::\n\n\n![](https://raw.githubusercontent.com/MarcellGranat/marcellgranat-website/main/static/currr/example2.gif){align=\"center\" fig-align=\"center\" width=\"100%\"}\n\nIn the example above, you get your results, when 20 iterations are evaluated, but the job in the background keeps running.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}