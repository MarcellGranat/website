{
  "hash": "d5b7b302fd693a2784d47bd1a60f2a2d",
  "result": {
    "markdown": "---\ntitle: currr\nauthor: Marcell Granat\ndate: '2023-02-14'\nformat: hugo\nslug: currr\ntags:\n  - currr\nsummary: \"I've recently developed a new R package called `currr` (checkpoints & purrr), and I'm thrilled to share it with you. With currr, you can easily manage time-consuming iterations, parallel computing and multitasking.\"\nlinks:\n- icon: code\n  icon_pack: fas\n  name: GitHub\n  url: https://github.com/MarcellGranat/currr\n- icon: link\n  icon_pack: fas\n  name: Website\n  url: https://marcellgranat.com/currr\n---\n\n\n\n# currr <img src=\"https://raw.githubusercontent.com/MarcellGranat/marcellgranat-website/main/static/currr/logo.png\" align=\"right\" width=\"120px\" />\n\n<!-- badges: start -->\n\n[![CRAN_Status_Badge](https://www.r-pkg.org/badges/version/currr)\n<!-- badges: end -->\n\n## Overview\n\n> A long journey is best broken into small steps, and the importance of\n> taking a rest must never be underestimated.\n\nThe **currr** package is a wrapper for the `purrr::map()` family but\nextends the iteration process with a certain number of **checkpoints**\n(`currr` = `c`heckpoints + `purrr`), where the evaluated results are\nsaved, and we can always restart from there.\n\n<img src=\"https://raw.githubusercontent.com/MarcellGranat/marcellgranat-website/main/static/currr/example.gif\" align=\"center\" />\n\nImplementations of the family of map() functions with a frequent saving\nof the intermediate results. The contained functions let you **start**\nthe evaluation of the iterations **where you stopped** (reading the\nalready evaluated ones from the cache), and **work with the currently\nevaluated iterations** while the remaining ones are running in a\nbackground job. **Parallel** computing is also easier with the `workers`\nparameter.\n\n## Installation\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"currr\")\n```\n:::\n\n\n\n## Usage\n\nThe following example uses `currr` to present an everyday issue: run a\ntime-demanding iteration, but you want to rerun it again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.1     ✔ purrr   1.0.1\n✔ tibble  3.2.1     ✔ dplyr   1.1.1\n✔ tidyr   1.3.0     ✔ stringr 1.5.0\n✔ readr   2.1.4     ✔ forcats 1.0.0\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nlibrary(currr)\n\noptions(currr.folder = \".currr\", currr.wait = Inf)\n# folder in your wd, where to save cache data\n\navg_n <- function(.data, .col, x) {\n  # meaningless function that takes about 1 sec\n  Sys.sleep(1)\n\n  .data |>\n    dplyr::pull({{ .col }}) |>\n    (\\(m) mean(m) * x) ()\n}\n```\n:::\n\n\n\n### Checkpoints\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntictoc::tic(msg = \"First evaluation\")\n\ncp_map(.x = 1:50, .f = avg_n, .data = iris,\n       .col = Sepal.Length,\n       name = \"iris_mean\") |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n✓ Everything is unchanged. Reading cache.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n|██████████████████████████████████████████████████ | 12% ETA:  45 sec                         \n|██████████████████████████████████████████████████ | 14% ETA:  44 sec                         \n|██████████████████████████████████████████████████ | 16% ETA:  25 sec (polynomial est.)       \n|██████████████████████████████████████████████████ | 18% ETA:  42 sec                         \n|██████████████████████████████████████████████████ | 20% ETA:  41 sec                         \n|██████████████████████████████████████████████████ | 22% ETA:  1 min 29 sec (polynomial est.) \n|██████████████████████████████████████████████████ | 24% ETA:  39 sec                         \n|██████████████████████████████████████████████████ | 26% ETA:  38 sec                         \n|██████████████████████████████████████████████████ | 28% ETA:  37 sec                         \n|██████████████████████████████████████████████████ | 30% ETA:  36 sec                         \n|██████████████████████████████████████████████████ | 32% ETA:  35 sec                         \n|██████████████████████████████████████████████████ | 34% ETA:  34 sec                         \n|██████████████████████████████████████████████████ | 36% ETA:  33 sec                         \n|██████████████████████████████████████████████████ | 38% ETA:  32 sec                         \n|██████████████████████████████████████████████████ | 40% ETA:  31 sec                         \n|██████████████████████████████████████████████████ | 42% ETA:  30 sec                         \n|██████████████████████████████████████████████████ | 44% ETA:  29 sec                         \n|██████████████████████████████████████████████████ | 46% ETA:  28 sec                         \n|██████████████████████████████████████████████████ | 48% ETA:  27 sec                         \n|██████████████████████████████████████████████████ | 50% ETA:  26 sec                         \n|██████████████████████████████████████████████████ | 52% ETA:  25 sec                         \n|██████████████████████████████████████████████████ | 54% ETA:  24 sec                         \n|██████████████████████████████████████████████████ | 56% ETA:  23 sec                         \n|██████████████████████████████████████████████████ | 58% ETA:  22 sec                         \n|██████████████████████████████████████████████████ | 60% ETA:  21 sec                         \n|██████████████████████████████████████████████████ | 62% ETA:  20 sec                         \n|██████████████████████████████████████████████████ | 64% ETA:  19 sec                         \n|██████████████████████████████████████████████████ | 66% ETA:  18 sec                         \n|██████████████████████████████████████████████████ | 68% ETA:  17 sec                         \n|██████████████████████████████████████████████████ | 70% ETA:  16 sec                         \n|██████████████████████████████████████████████████ | 72% ETA:  15 sec                         \n|██████████████████████████████████████████████████ | 74% ETA:  14 sec                         \n|██████████████████████████████████████████████████ | 76% ETA:  13 sec                         \n|██████████████████████████████████████████████████ | 78% ETA:  12 sec                         \n|██████████████████████████████████████████████████ | 80% ETA:  11 sec                         \n|██████████████████████████████████████████████████ | 82% ETA:  10 sec                         \n|██████████████████████████████████████████████████ | 84% ETA:  9 sec                          \n|██████████████████████████████████████████████████ | 86% ETA:  8 sec                          \n|██████████████████████████████████████████████████ | 88% ETA:  7 sec                          \n|██████████████████████████████████████████████████ | 90% ETA:  6 sec                          \n|██████████████████████████████████████████████████ | 92% ETA:  5 sec                          \n|██████████████████████████████████████████████████ | 94% ETA:  4 sec                          \n|██████████████████████████████████████████████████ | 96% ETA:  3 sec                          \n|██████████████████████████████████████████████████ | 98% ETA:  2 sec                          \n|██████████████████████████████████████████████████ | 100% ETA:  0 sec                          \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 5.843333\n\n[[2]]\n[1] 11.68667\n\n[[3]]\n[1] 17.53\n```\n:::\n\n```{.r .cell-code}\ntictoc::toc() # ~ 1:50 => 50 x 1 sec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFirst evaluation: 47.778 sec elapsed\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntictoc::tic(msg = \"Second evaluation\")\n\ncp_map(.x = 1:50, .f = avg_n, .data = iris,\n       .col = Sepal.Length,\n       name = \"iris_mean\") |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n✓ Everything is unchanged. Reading cache.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 5.843333\n\n[[2]]\n[1] 11.68667\n\n[[3]]\n[1] 17.53\n```\n:::\n\n```{.r .cell-code}\ntictoc::toc() # ~ 0 sec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSecond evaluation: 0.041 sec elapsed\n```\n:::\n:::\n\n\nIf the `.x` input and `.f` are the same, then the 2nd time you call the\nfunction, it reads the outcome from the specified folder (`.currr`).\nAlso if `.x` changes, but some of its part remain the same, then that\npart is taken from the previously saved results, and only the new\nelements of `.x` are called for evaluation. (If `.f` changes, then the\nprocess will start from zero.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntictoc::tic(msg = \"Partly modification\")\n\ncp_map(.x = 20:60, .f = avg_n, .data = iris,\n       .col = Sepal.Length,\n       name = \"iris_mean\") |>\n  head(3)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n⚠ .x has changed. Looking for mathcing result to save them as cache\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n◌ Cache updated based on the new .x values\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n|███████████████████████████████████████████████████████████████████████████████████████ | 2% ETA:  41 sec                         \n|█████████████████████████████████████████████████████████████████████████████████████ | 6% ETA:  40 sec                         \n|████████████████████████████████████████████████████████████████████████████████████ | 8% ETA:  39 sec                         \n|███████████████████████████████████████████████████████████████████████████████████ | 10% ETA:  38 sec                         \n|██████████████████████████████████████████████████████████████████████████████████ | 12% ETA:  37 sec                         \n|████████████████████████████████████████████████████████████████████████████████ | 16% ETA:  36 sec                         \n|███████████████████████████████████████████████████████████████████████████████ | 18% ETA:  35 sec                         \n|██████████████████████████████████████████████████████████████████████████████ | 20% ETA:  34 sec                         \n|█████████████████████████████████████████████████████████████████████████████ | 22% ETA:  33 sec                         \n|████████████████████████████████████████████████████████████████████████████ | 24% ETA:  32 sec                         \n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 116.8667\n\n[[2]]\n[1] 122.71\n\n[[3]]\n[1] 128.5533\n```\n:::\n\n```{.r .cell-code}\ntictoc::toc() # ~ 50:60 => 10 x 1 sec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPartly modification: 10.546 sec elapsed\n```\n:::\n:::\n\n\nYou can remove the cache files, if you want to reset the process (or\nremove the already unnecessary files from your folder).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# only cache files for iris_mean\nremove_currr_cache(\"iris_mean\")\n\n# all cache files\nremove_currr_cache()\n```\n:::\n\n\n### Background process\n\nThis is another functionality that makes `currr` to be cool. Working in\nRStudio you can set the `wait` parameter to 0-1/1+, define how many\niterations you want to wait, and then let R work on the remaining\niterations in the background, while you can work with the evaluated\nones. If wait \\< 1, then it is interpreted as what proportion of the\niterations you want to wait. Whenever you recall the function, it will\nreturn the already evaluated ones (use the `fill` parameter to specify\nwhether you want to get `NULL`s to the pending ones.)\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(currr.wait = 20, currr.fill = FALSE)\n```\n:::\n\n\n<img src=\"https://raw.githubusercontent.com/MarcellGranat/marcellgranat-website/main/static/currr/example2.gif\" align=\"center\" />\n\nIn the example above, you get your results, when 20 iterations are\nevaluated, but the job in the background keeps running.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}